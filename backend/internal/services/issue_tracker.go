package services

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/huangang/codesentry/backend/internal/models"
	"github.com/huangang/codesentry/backend/pkg/logger"
	"gorm.io/gorm"
)

// IssueTrackerService manages issue tracker integrations and auto-issue creation.
type IssueTrackerService struct {
	db         *gorm.DB
	httpClient *http.Client
}

func NewIssueTrackerService(db *gorm.DB) *IssueTrackerService {
	return &IssueTrackerService{
		db:         db,
		httpClient: &http.Client{Timeout: 15 * time.Second},
	}
}

type CreateIssueRequest struct {
	Title       string
	Description string
	Author      string
	ProjectName string
	CommitHash  string
	Score       float64
	ReviewURL   string
}

// CheckAndCreateIssue checks all active issue trackers and creates issues for low-score reviews.
func (s *IssueTrackerService) CheckAndCreateIssue(reviewLog *models.ReviewLog, projectName string) {
	if reviewLog.Score == nil || *reviewLog.Score >= 60 {
		return // Skip if no score or score is acceptable
	}

	var trackers []models.IssueTracker
	s.db.Where("is_active = ?", true).Find(&trackers)

	for _, tracker := range trackers {
		if *reviewLog.Score < tracker.ScoreThreshold {
			req := CreateIssueRequest{
				Title:       fmt.Sprintf("[CodeSentry] Low Score Review: %s (%.0f/100)", reviewLog.CommitHash[:8], *reviewLog.Score),
				Description: s.buildDescription(reviewLog, projectName),
				Author:      reviewLog.Author,
				ProjectName: projectName,
				CommitHash:  reviewLog.CommitHash,
				Score:       *reviewLog.Score,
			}
			if err := s.createIssue(&tracker, &req); err != nil {
				logger.Infof("[IssueTracker] Failed to create issue in %s: %v", tracker.Name, err)
			} else {
				logger.Infof("[IssueTracker] Created issue in %s for commit %s", tracker.Name, reviewLog.CommitHash[:8])
			}
		}
	}
}

func (s *IssueTrackerService) buildDescription(log *models.ReviewLog, projectName string) string {
	scoreStr := "N/A"
	if log.Score != nil {
		scoreStr = fmt.Sprintf("%.0f/100", *log.Score)
	}
	return fmt.Sprintf(`## Code Review Alert

**Project**: %s
**Author**: %s
**Branch**: %s
**Commit**: %s
**Score**: %s

### Commit Message
%s

### Review Result
%s

---
*Auto-generated by CodeSentry*`, projectName, log.Author, log.Branch, log.CommitHash, scoreStr, log.CommitMessage, log.ReviewResult)
}

func (s *IssueTrackerService) createIssue(tracker *models.IssueTracker, req *CreateIssueRequest) error {
	switch tracker.Type {
	case "jira":
		return s.createJiraIssue(tracker, req)
	case "linear":
		return s.createLinearIssue(tracker, req)
	case "github_issues":
		return s.createGitHubIssue(tracker, req)
	default:
		return fmt.Errorf("unsupported issue tracker type: %s", tracker.Type)
	}
}

func (s *IssueTrackerService) createJiraIssue(tracker *models.IssueTracker, req *CreateIssueRequest) error {
	payload := map[string]interface{}{
		"fields": map[string]interface{}{
			"project":     map[string]string{"key": tracker.ProjectKey},
			"summary":     req.Title,
			"description": req.Description,
			"issuetype":   map[string]string{"name": tracker.IssueType},
		},
	}
	if tracker.Labels != "" {
		payload["fields"].(map[string]interface{})["labels"] = []string{tracker.Labels}
	}

	body, _ := json.Marshal(payload)
	httpReq, err := http.NewRequest("POST", tracker.BaseURL+"/rest/api/2/issue", bytes.NewReader(body))
	if err != nil {
		return err
	}
	httpReq.Header.Set("Content-Type", "application/json")
	httpReq.Header.Set("Authorization", "Basic "+tracker.APIToken)

	resp, err := s.httpClient.Do(httpReq)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode >= 400 {
		return fmt.Errorf("jira returned status %d", resp.StatusCode)
	}
	return nil
}

func (s *IssueTrackerService) createLinearIssue(tracker *models.IssueTracker, req *CreateIssueRequest) error {
	query := `mutation($title: String!, $description: String!, $teamId: String!) {
		issueCreate(input: { title: $title, description: $description, teamId: $teamId }) {
			success
			issue { id identifier }
		}
	}`
	payload := map[string]interface{}{
		"query": query,
		"variables": map[string]string{
			"title":       req.Title,
			"description": req.Description,
			"teamId":      tracker.ProjectKey,
		},
	}

	body, _ := json.Marshal(payload)
	httpReq, err := http.NewRequest("POST", "https://api.linear.app/graphql", bytes.NewReader(body))
	if err != nil {
		return err
	}
	httpReq.Header.Set("Content-Type", "application/json")
	httpReq.Header.Set("Authorization", tracker.APIToken)

	resp, err := s.httpClient.Do(httpReq)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode >= 400 {
		return fmt.Errorf("linear returned status %d", resp.StatusCode)
	}
	return nil
}

func (s *IssueTrackerService) createGitHubIssue(tracker *models.IssueTracker, req *CreateIssueRequest) error {
	payload := map[string]interface{}{
		"title": req.Title,
		"body":  req.Description,
	}
	if tracker.Labels != "" {
		payload["labels"] = []string{tracker.Labels}
	}

	body, _ := json.Marshal(payload)
	url := fmt.Sprintf("%s/repos/%s/issues", tracker.BaseURL, tracker.ProjectKey)
	httpReq, err := http.NewRequest("POST", url, bytes.NewReader(body))
	if err != nil {
		return err
	}
	httpReq.Header.Set("Content-Type", "application/json")
	httpReq.Header.Set("Authorization", "Bearer "+tracker.APIToken)

	resp, err := s.httpClient.Do(httpReq)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode >= 400 {
		return fmt.Errorf("github returned status %d", resp.StatusCode)
	}
	return nil
}

// --- CRUD for IssueTracker ---

func (s *IssueTrackerService) List() ([]models.IssueTracker, error) {
	var trackers []models.IssueTracker
	if err := s.db.Find(&trackers).Error; err != nil {
		return nil, err
	}
	// Mask API tokens
	for i := range trackers {
		if len(trackers[i].APIToken) > 8 {
			trackers[i].APITokenMask = trackers[i].APIToken[:4] + "****" + trackers[i].APIToken[len(trackers[i].APIToken)-4:]
		} else if trackers[i].APIToken != "" {
			trackers[i].APITokenMask = "****"
		}
	}
	return trackers, nil
}

func (s *IssueTrackerService) Create(tracker *models.IssueTracker) error {
	return s.db.Create(tracker).Error
}

func (s *IssueTrackerService) Update(id uint, updates map[string]interface{}) (*models.IssueTracker, error) {
	var tracker models.IssueTracker
	if err := s.db.First(&tracker, id).Error; err != nil {
		return nil, err
	}
	if err := s.db.Model(&tracker).Updates(updates).Error; err != nil {
		return nil, err
	}
	s.db.First(&tracker, id)
	return &tracker, nil
}

func (s *IssueTrackerService) Delete(id uint) error {
	return s.db.Delete(&models.IssueTracker{}, id).Error
}
